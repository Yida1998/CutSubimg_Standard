最终版本:为了和算法2生成相同数目的训练样本

1.运行代码1生成字典
2.运行代码2一键调用算法2



一键运行算法2:土壤子图选择算法.


---

2022年03月02日10:19:42

## 逻辑说明
1. 直接运行onekey即可得到结果
2. 可以设置子图大小224, 但是滑动窗口应该没有调整, 所以只能设置224
3. 默认的获取土壤最小外接矩形加速运算, 也可以不获取, 后面应该会计算出时间
4. 分了区间, 看一下区间是如何分的?

    - 分了两种情况, 第一种就是是不是要进行区间限制
    - 需要的话就分成N个区间
    - 不需要的话就方法1和方法2选择一种
    - 方法2的话就是中心极限, 仅保留百分之95的权重矩阵
    - 方法1的话就是分区间, 舍弃两个端区间的一半, 且在进行区间划分的时候才进行
    
## 问题
1. 这个分区间不太可控, 感觉逻辑不是很清晰, 而且现在需要根据论文改动哦!
2. 子图大小 不灵活 写死了 不好自适应!
3. 根据现有的实验来进行代码修改
4. 自适应的问题? 论文里面没有提?怎么办> ?
5. 还有就是自定义子图数, 你不能和这个OneKeyCode结合再一起吗?
答: 这个自定义子图数处理得很机制, 可扩展性很强, 写一个开关把是否自定义子图数加进来

### 实验越多, 不确定性越多!所以怎么办???
### 现在来看一下, 自定义子图数是如何处理的.

### 考虑一下实验, 想一想如何设计架构, 需要做到哪些实验, 把接口设计好

运行完代码之后 可以使用 Tool中的移动工具来归纳数据集

2022年03月04日15:58:34
run.sh 是批量运行代码


算法2 直接运行2OneKeyCode.py得到结果, 如果数据集太多可以使用Tools的CombinationTrainTest.py 合并数据集
参数说明:
--path: 土壤原图数据集路径(已经分割好背景的, /data/各个类的文件夹/图片 有一点就是这里面指定了文件夹名称的, 所以你要改数据集就得改对应的class_img)
--bbox: 是否使用最小外接矩形加速运算, 默认为True, 当为True时将获取的最小外接矩形保存在同级的Rectangle文件夹下
--img_size: 设置土壤图像的大小, 为偶数会好一点, 方便后面的训练, 不要取太小比如小于50 有些网络不太能识别
--same_path: 为了让算法2获取与算法1相同的子图数, 输入想要与相同土壤子图数据集路径; 当不开启自适应, 且num_sum为0的时候读取这个路径
--adaption: 默认为True, 开启自适应子图切割, 获取的子图数, 与每张图像的长宽及获取的子图大小有关
--rate: 字典类型{'m\l\r' 中间, 左边, 右边: 比例 }, 当{m:0}时不进行w矩阵两端的舍弃操作, 将对应W设置为0, 当为m的时候, 是把比例除以2
-> 没有对rate进行类型的判定, 而是直接传入一个字典? 这样的行为真的很蠢, 且不具有鲁棒性
--ratefip: 默认为False, 将舍弃的w区域进行取反, 把其它区域置为0, 仅在这个区域进行选择
--num_num: 默认为10,  获取10张土壤子图, 当自适应adaption关闭时, 选择num_num张土壤子图, 但当它为0时, 会主动去加载same_path路径
--broke: 默认为False, 不然的话你要传入一个字典{m:替换比例}, 一个是在两端\左边\右边进行选择, 一个是替换比例; 但是如何在定义过亮或者阴影区域 需要自己定义这个范围
--datasetname_end: 默认为空字符, 因为broke或者随机子图选择时, 获取多次数据集会重复, 所以添加一个结尾字符, 用于区分不同子集, 如1,2,3等
--random: 默认为False, 当它为true时 默认在w矩阵中随机进行土壤子图选择